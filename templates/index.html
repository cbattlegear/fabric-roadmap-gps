
    {% extends 'base.html' %}
    {% block title %}Fabric GPS - Microsoft Fabric Roadmap Tracker{% endblock %}

    
{% block herotitle%}Microsoft Fabric Roadmap Tracker{% endblock %}
{% block herosubtitle%}
Stay up-to-date with the latest Microsoft Fabric roadmap updates.
Get real-time feeds and explore what's coming next.
{% endblock %}
{% block content %}
        <div class="container">
            <section class="card-grid">
                <div class="card">
                    <h2 class="card-title">ðŸ“¡ RSS Feed</h2>
                    <p class="card-description">
                        Subscribe to our RSS feed to get the latest roadmap updates delivered directly to your feed reader.
                        Perfect for staying informed about new features and release dates.
                    </p>
                    <a href="/rss" class="button button-primary">View RSS Feed</a>
                    <a href="/rss.xml" class="button button-secondary" style="margin-left: 0.5rem;">Download XML</a>
                </div>

                <div class="card">
                    <h2 class="card-title">ðŸ”Œ JSON API</h2>
                    <p class="card-description">
                        Access structured roadmap data through our REST API. Filter by product, release type, status,
                        or recent changes. Perfect for integrations and custom applications.
                    </p>
                    <a href="/api/releases" class="button button-primary">Explore API</a>
                    <a href="/endpoints" class="button button-secondary" style="margin-left: 0.5rem;">Documentation</a>
                </div>

                <div class="card">
                    <h2 class="card-title">ðŸ“¨ Email Updates</h2>
                    <p class="card-description">
                        Get one concise Monday email summarizing the week's Microsoft Fabric roadmap changesâ€”focused
                        highlights that prep you for the week without noise or inbox clutter.
                    </p>
                    <a href="/subscribe" class="button button-primary">Subscribe Now</a>
                </div>
            </section>

            <section class="recent-changes-section">
                <h2 class="section-title">Recent Changes</h2>
                <div class="recent-changes-content">
                    <div class="filters-container">
                        <div class="filter-group">
                            <label for="product-filter">Product:</label>
                            <select id="product-filter" class="filter-select">
                                <option value="">All Products</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="type-filter">Release Type:</label>
                            <select id="type-filter" class="filter-select">
                                <option value="">All Types</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="status-filter">Status:</label>
                            <select id="status-filter" class="filter-select">
                                <option value="">All Statuses</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="days-filter">Modified Within:</label>
                            <select id="days-filter" class="filter-select">
                                <option value="">All Time</option>
                                <option value="7">Last 7 days</option>
                                <option value="14">Last 14 days</option>
                                <option value="30">Last 30 days</option>
                            </select>
                        </div>
                        <div class="filter-group">
                            <label for="search-input">Search:</label>
                            <input id="search-input" class="filter-select" type="search" placeholder="Search features, descriptions, products..." />
                        </div>
                        <button id="apply-filters" class="button button-primary">Apply Filters</button>
                        <button id="clear-filters" class="button button-secondary">Clear</button>
                    </div>
                    
                    <div class="loading-indicator" id="loading-indicator" style="display: none;">
                        <div class="spinner"></div>
                        <span>Loading recent changes...</span>
                    </div>
                    
                    <div class="changes-grid" id="changes-grid">
                        <!-- Changes will be populated by JavaScript -->
                    </div>
                    <div id="loading-more-indicator" style="display:none; text-align:center; padding:.75rem 0; font-size:.75rem; opacity:.7;">Loading moreâ€¦</div>
                    <div style="text-align:center; margin-top:.5rem;">
                        <button id="load-more-btn" class="button button-secondary" style="display:none;">Load More</button>
                    </div>
                     <div id="infinite-scroll-sentinel" style="height:1px;"></div>
                    
                    <div class="no-results" id="no-results" style="display: none;">
                        <p>No changes found matching your filters. Try adjusting your criteria.</p>
                    </div>
                </div>
            </section>
        </div>
    <div id="release-modal" class="modal" aria-hidden="true" role="dialog" aria-modal="true">
        <div class="modal-backdrop" data-modal-close></div>
        <div class="modal-dialog" role="document">
            <button class="modal-close" title="Close" data-modal-close>&times;</button>
            <div id="modal-content" class="modal-content">
                <!-- Filled dynamically -->
            </div>
        </div>
    </div>
{% endblock %}
{% block scripts %}

<script>
        class ReleaseModal {
            constructor() {
                this.modal = document.getElementById('release-modal');
                this.content = document.getElementById('modal-content');
                this.bindGlobal();
                this.checkHashOnLoad();
            }
            bindGlobal() {
                document.querySelectorAll('[data-modal-close]').forEach(el => {
                    el.addEventListener('click', () => this.hide());
                });
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.isOpen()) this.hide();
                });
            }
            isOpen() { return this.modal.getAttribute('aria-hidden') === 'false'; }
            show() { this.modal.setAttribute('aria-hidden', 'false'); document.body.style.overflow='hidden'; }
            hide() { this.modal.setAttribute('aria-hidden', 'true'); document.body.style.overflow=''; this.clearHashIfMatches(); }
            clearHashIfMatches(){ if (location.hash.startsWith('#release/')) { history.replaceState(null,'',location.pathname+location.search); } }
            async openById(id) {
                try {
                    const r = await fetch(`/api/releases?release_item_id=${encodeURIComponent(id)}`);
                    if (!r.ok){ this.renderError(`Item not found (${id})`); return; }
                    const data = await r.json();
                    this.renderItemShell(data); // initial render without history
                    this.show();
                    if(!location.hash.includes(id)) { history.replaceState(null,'',`#release/${id}`); }
                    // Fetch history (non-blocking)
                    this.loadHistory(id);
                } catch(err){ this.renderError('Error loading item'); }
            }
            renderItemShell(item){
                const relDate = item.release_date ? new Date(item.release_date).toLocaleDateString() : 'TBD';
                const lm = item.last_modified ? new Date(item.last_modified).toLocaleDateString() : 'Unknown';
                const typeClass = item.release_type === 'General availability' ? 'success' : 'warn';
                const statusClass = item.release_status === 'Shipped' ? 'success' : 'warn';
                this.content.innerHTML = `
                    <div class="modal-header">
                        <h2 class="modal-title">${this.escape(item.feature_name || 'Unnamed Feature')}</h2>
                        <div class="modal-meta-row">
                            <span class="modal-release-info">Status: ${this.escape(item.release_status || 'Unknown Status')} ${this.escape(item.release_type || 'Unknown Type')} on ${this.escape(relDate)}</span>
                            <span class="modal-last-modified">Last Modified: ${this.escape(lm)}</span>
                        </div>
                    </div>
                    <div class="modal-section">
                        <div class="modal-description">${this.escape(item.feature_description || 'No description provided.')}</div>
                    </div>
                    <div class="modal-section" id="history-section">
                        <h4>Change History</h4>
                        <div class="history-loading" style="font-size:.8rem; opacity:.7;">Loading history...</div>
                        <ol class="history-timeline" style="list-style:none; padding:0; margin: .5rem 0 0 0;"></ol>
                    </div>
                    <div class="modal-actions-row">
                        <span class="modal-action-buttons">
                            <button class="link-copy" data-copy-link>Copy Direct Link</button>
                            <a class="button button-secondary" href="/api/releases?release_item_id=${encodeURIComponent(item.release_item_id)}" target="_blank" rel="noopener">Open API JSON</a>
                        </span>
                        <span class="modal-workload-name">Workload: ${this.escape(item.product_name || 'Unknown Workload')}</span>
                    </div>
                `;
                this.bindCopy(item.release_item_id);
            }
            bindCopy(id){
                const copyBtn = this.content.querySelector('[data-copy-link]');
                if (copyBtn) {
                    copyBtn.addEventListener('click', () => {
                        const link = `${location.origin}${location.pathname}#release/${id}`;
                        navigator.clipboard.writeText(link).then(()=>{
                            const old = copyBtn.textContent; copyBtn.textContent='Link Copied'; setTimeout(()=>copyBtn.textContent=old,1500);
                        });
                    });
                }
            }
            async loadHistory(id){
                try {
                    const r = await fetch(`/api/releases/history/${encodeURIComponent(id)}`);
                    if(!r.ok){ this.renderHistoryError('History unavailable'); return; }
                    const hist = await r.json();
                    this.renderHistory(hist);
                } catch(err){ this.renderHistoryError('History error'); }
            }
            renderHistory(hist){
                const section = this.content.querySelector('#history-section');
                if(!section) return;
                const loading = section.querySelector('.history-loading');
                if (loading) loading.remove();
                const list = section.querySelector('.history-timeline');
                if(!hist || hist.length === 0){
                    list.innerHTML = '<li style="font-size:.8rem; opacity:.7;">No history entries.</li>';
                    return;
                }
                list.innerHTML = hist.map(h => {
                    const lm = h.last_modified ? new Date(h.last_modified).toLocaleDateString() : 'Unknown';
                    const changes = (h.changed_columns && h.changed_columns.length) ? h.changed_columns.map(c=>`<code style="background:var(--fabric-neutral-grey-20); padding:2px 4px; border-radius:3px;">${this.escape(c)}</code>`).join(' ') : '<span style="opacity:.6;">(no column list)</span>';
                    return `<li style="margin: .5rem 0; line-height:1.4;">
                        <div style="font-size:.7rem; letter-spacing:.05em; text-transform:uppercase; color:var(--fabric-neutral-grey-90);">${this.escape(lm)}</div>
                        <div class="history-changes" style="margin-top:2px; font-size:.75rem;">${changes}</div>
                    </li>`;
                }).join('');
            }
            renderHistoryError(msg){
                const section = this.content.querySelector('#history-section');
                if(!section) return;
                const loading = section.querySelector('.history-loading');
                if (loading) loading.textContent = msg;
            }
            escape(t){ const d=document.createElement('div'); d.textContent=t||''; return d.innerHTML; }
            checkHashOnLoad(){ if (location.hash.startsWith('#release/')) { const id = location.hash.split('#release/')[1]; if (id) this.openById(id); } }
        }

        // Extend RecentChanges to open modal on item click
        class RecentChanges {
            constructor() {
                this.filterOptions = {};
                this.currentData = [];
                this.debounceTimer = null;
                this.minSearchLength = 2; // minimum chars to trigger search
                this.page = 1;
                this.pageSize = 15;
                this.pagination = null; // server-provided pagination metadata
                this.loadingMore = false;
                this.allPagesLoaded = false;
                this.observer = null;
                this.hasLoadedOnce = false;
                this.init();
            }

            async init() {
                await this.loadFilterOptions();
                await this.loadRecentChanges({ reset: true });
                this.bindEvents();
                this.setupInfiniteScroll();
            }

            async loadFilterOptions() {
                try {
                    const response = await fetch('/api/filter-options');
                    this.filterOptions = await response.json();
                    this.populateFilterSelects();
                } catch (error) {
                    console.error('Error loading filter options:', error);
                }
            }

            populateFilterSelects() {
                const productSelect = document.getElementById('product-filter');
                const typeSelect = document.getElementById('type-filter');
                const statusSelect = document.getElementById('status-filter');

                // Populate product names
                this.filterOptions.product_names.forEach(product => {
                    const option = document.createElement('option');
                    option.value = product;
                    option.textContent = product;
                    productSelect.appendChild(option);
                });

                // Populate release types
                this.filterOptions.release_types.forEach(type => {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = type;
                    typeSelect.appendChild(option);
                });

                // Populate release statuses
                this.filterOptions.release_statuses.forEach(status => {
                    const option = document.createElement('option');
                    option.value = status;
                    option.textContent = status;
                    statusSelect.appendChild(option);
                });
            }

            async loadRecentChanges(options = {}) {
                const { reset = false } = options;
                const filters = this.getActiveFilters();

                if (reset) {
                    this.page = 1;
                    this.currentData = []; // (DOM remains; we won't hide it unless true initial load)
                    this.allPagesLoaded = false;
                }

                if (this.loadingMore || this.allPagesLoaded) return;

                const isInitialLoad = this.page === 1 && !this.hasLoadedOnce;

                this.loadingMore = true;

                // Decide visual indicator strategy:
                // - First ever load: full loader (center)
                // - Any subsequent load (including filter/search resets): bottom loader only
                if (this.page > 1) {
                    this.toggleBottomLoading(true);
                } else if (isInitialLoad) {
                    this.showLoading(true);        // show main loader only once
                } else {
                    this.toggleBottomLoading(true); // preserve existing cards
                }

                try {
                    const params = new URLSearchParams();
                    if (filters.product_name) params.append('product_name', filters.product_name);
                    if (filters.release_type) params.append('release_type', filters.release_type);
                    if (filters.release_status) params.append('release_status', filters.release_status);
                    if (filters.modified_within_days) params.append('modified_within_days', filters.modified_within_days);
                    if (filters.q && String(filters.q).trim().length >= this.minSearchLength) {
                        params.append('q', String(filters.q).trim());
                    }
                    params.append('page', String(this.page));
                    params.append('page_size', String(this.pageSize));

                    const response = await fetch(`/api/releases?${params.toString()}`);
                    const payload = await response.json();
                    const items = Array.isArray(payload) ? payload : (payload.data || []);
                    items.sort((a, b) => new Date(b.last_modified) - new Date(a.last_modified));

                    if (this.page === 1) {
                        this.currentData = items;
                    } else {
                        this.currentData = this.currentData.concat(items);
                    }

                    this.pagination = payload.pagination || null;

                    if (this.pagination && this.page > this.pagination.total_pages) {
                        this.page = this.pagination.total_pages || 1;
                        this.loadingMore = false;
                        return this.loadRecentChanges({ reset: true });
                    }

                    if (this.pagination && !this.pagination.has_next) {
                        this.allPagesLoaded = true;
                    }

                    this.renderChanges();

                    if (this.pagination && this.pagination.has_next) {
                        this.page += 1;
                    }

                    if (!this.hasLoadedOnce && this.currentData.length > 0) {
                        this.hasLoadedOnce = true;
                    }
                } catch (error) {
                    console.error('Error loading recent changes:', error);
                    if (isInitialLoad) {
                        this.showError();
                    } else {
                        // Non-initial load error: keep old content; optionally flash a toast (not implemented)
                    }
                } finally {
                    if (isInitialLoad) {
                        this.showLoading(false);
                    }
                    this.toggleBottomLoading(false);
                    this.loadingMore = false;
                    this.updateLoadMoreButton();
                }
            }

            renderChanges() {
                const container = document.getElementById('changes-grid');
                const noResults = document.getElementById('no-results');

                if (this.currentData.length === 0) {
                    // Only show "no results" if this was genuinely the first load or a filter returning nothing
                    container.innerHTML = '';
                    noResults.style.display = 'block';
                    return;
                }

                noResults.style.display = 'none';
                container.innerHTML = this.currentData.map(item => this.createChangeItem(item)).join('');
                container.querySelectorAll('.change-item').forEach(card => {
                    card.addEventListener('click', () => {
                        const id = card.getAttribute('data-id');
                        window.__releaseModal.openById(id);
                    });
                });
            }

            createChangeItem(item) {
                const date = new Date(item.last_modified).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                });

                const releaseDate = item.release_date ? new Date(item.release_date).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                }) : 'TBD';

                const releaseTypeClass = item.release_type == 'General availability' ? 'badge-success' : 'badge-warning';
                const releaseStatusClass = item.release_status == 'Shipped' ? 'badge-success' : 'badge-warning';

                return `
                    <div class="change-item" data-id="${this.escapeHtml(item.release_item_id)}" role="button" tabindex="0" aria-label="View details for ${this.escapeHtml(item.feature_name || 'feature')}">
                        <div class="change-header">
                            <h3 class="change-title">${this.escapeHtml(item.feature_name || 'Unnamed Feature')}</h3>
                            <div class="change-badges">
                                <span class="change-badge badge-product">${this.escapeHtml(item.product_name || 'Unknown')}</span>
                                <span class="change-badge ${releaseTypeClass}">${this.escapeHtml(item.release_type || 'Unknown')}</span>
                                <span class="change-badge ${releaseStatusClass}">${this.escapeHtml(item.release_status || 'Unknown')}</span>
                            </div>
                        </div>
                        <div class="change-meta">
                            <span class="change-date">Last Modified: ${date}</span>
                            <span class="release-date">Release Date: ${releaseDate}</span>
                        </div>
                        <p class="change-description">${this.escapeHtml(item.feature_description || 'No description available.')}</p>
                        <div class="change-link-inline" style="margin-top:.5rem; font-size:.75rem; color: var(--fabric-primary);">Click for details â–¸</div>
                    </div>`;
            }
            bindEvents() {
                 const applyBtn = document.getElementById('apply-filters');
                 const clearBtn = document.getElementById('clear-filters');
                const loadMoreBtn = document.getElementById('load-more-btn');

                 // Debounced search input handling
                 const searchInput = document.getElementById('search-input');
                 if (searchInput) {
                     searchInput.addEventListener('input', (e) => {
                         this.debounceSearch(); // debounce will trigger reset load when long enough
                     });
                 }

                 applyBtn.addEventListener('click', () => {
                     this.loadRecentChanges({ reset: true });
                 });

                 clearBtn.addEventListener('click', () => {
                     this.clearFilters();
                     this.loadRecentChanges({ reset: true });
                 });

                if (loadMoreBtn) {
                    loadMoreBtn.addEventListener('click', () => {
                        this.loadRecentChanges({ reset: false });
                    });
                }
                 // Allow Enter key to apply filters
                 document.querySelectorAll('.filter-select').forEach(select => {
                     select.addEventListener('keypress', (e) => {
                         if (e.key === 'Enter') {
                             this.loadRecentChanges({ reset: true });
                         }
                     });
                 });
             }

            getActiveFilters() {
                return {
                    product_name: document.getElementById('product-filter').value,
                    release_type: document.getElementById('type-filter').value,
                    release_status: document.getElementById('status-filter').value,
                    modified_within_days: document.getElementById('days-filter').value,
                    q: (document.getElementById('search-input') && document.getElementById('search-input').value) || ''
                };
            }

            clearFilters() {
                document.getElementById('product-filter').value = '';
                document.getElementById('type-filter').value = '';
                document.getElementById('status-filter').value = '';
                document.getElementById('days-filter').value = '';
                const si = document.getElementById('search-input');
                if (si) si.value = '';
                this.page = 1;
                this.allPagesLoaded = false;
                this.currentData = [];
             }
            updateLoadMoreButton() {
                const btn = document.getElementById('load-more-btn');
                if (!btn) return;
                if (this.observer) {
                    // IntersectionObserver active â€” hide manual button unless all loaded
                    btn.style.display = this.allPagesLoaded ? 'none' : 'none';
                } else {
                    // Fallback mode
                    btn.style.display = this.allPagesLoaded ? 'none' : 'inline-block';
                    btn.disabled = this.loadingMore;
                }
            }
            toggleBottomLoading(show) {
                const el = document.getElementById('loading-more-indicator');
                if (!el) return;
                el.style.display = show ? 'block' : 'none';
            }
            
            showLoading(show) {
                const loader = document.getElementById('loading-indicator');
                const grid = document.getElementById('changes-grid');
                const noResults = document.getElementById('no-results');

                if (show) {
                    loader.style.display = 'flex';
                    // Only hide grid if it has no content yet (true initial load)
                    if (!this.hasLoadedOnce) {
                        grid.style.display = 'none';
                        noResults.style.display = 'none';
                    }
                } else {
                    loader.style.display = 'none';
                    grid.style.display = 'grid';
                }
            }

            showError() {
                const container = document.getElementById('changes-grid');
                const noResults = document.getElementById('no-results');
                
                container.innerHTML = '';
                noResults.innerHTML = '<p>Error loading changes. Please try again later.</p>';
                noResults.style.display = 'block';
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            debounceSearch(delay = 300) {
                if (this.debounceTimer) clearTimeout(this.debounceTimer);
                this.debounceTimer = setTimeout(() => {
                    const filters = this.getActiveFilters();
                    // If search text is too short and non-empty, don't send 'q' param (acts like no-search)
                    if (filters.q && String(filters.q).trim().length > 0 && String(filters.q).trim().length < this.minSearchLength) {
                        // do not search yet
                        return;
                    }
                    this.loadRecentChanges({ reset: true });
                }, delay);
             }

            setupInfiniteScroll() {
                const sentinel = document.getElementById('infinite-scroll-sentinel');
                if (!('IntersectionObserver' in window) || !sentinel) return;
                this.observer = new IntersectionObserver(entries => {
                    for (const entry of entries) {
                        if (entry.isIntersecting) {
                            this.loadRecentChanges({ reset: false });
                        }
                    }
                }, { root: null, rootMargin: '0px 0px 300px 0px', threshold: 0 });
                this.observer.observe(sentinel);
                // Always update button (fallback or not)
                this.updateLoadMoreButton();
            }
            maybePreloadNext() {
                if (this.allPagesLoaded || this.loadingMore) return;
                const sentinel = document.getElementById('infinite-scroll-sentinel');
                if (!sentinel) return;
                const rect = sentinel.getBoundingClientRect();
                if (rect.top < window.innerHeight + 300) {
                    this.loadRecentChanges({ reset: false });
                }
            }
        }
        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            window.__releaseModal = new ReleaseModal();
            new RecentChanges();
        });
    </script>
{% endblock %}
